# Chapter 6 -  스트림으로 데이터 수집
## 이전 내용의 복습
Java8의 스트림은 데이터 집합을 멋지게 처리하는 게으른 반복자라고 설명할 수 있습니다.  
중간 연산(filter, map 같은)은 스트림의 요소를 소비하지 않습니다. 반면, 최종 연산은 스트림의 요소를 소비해서  
최종 결과를 도출합니다(예를 들어 가장 큰 값 반환).
  
최종 연산은 스트림 파이프라인을 최적화하면서 계산 과정을 짧게 생략하기도 합니다.  
  
이 장에서는 reduce가 그랬던 것처럼 collect 역시 다양한 요소 누적 방식을 인수로 받아서 스트림을 최종 결과로 도출하는  
리듀싱 연산을 수행할 수 있음을 설명합니다. 다양한 요소 누적 방식은 Collector 인터페이스에 정의되어 있습니다.  
  
## collect VS Collector VS Collectors
- collect : 스트림의 최종 연산 메서드 중 하나입니다.  
- Collector : collect에서 필요한 메서드를 정의해놓은 인터페이스입니다.  
- Collectors : 복수형이 잘 나타내듯이 `Collector`를 구현한 클래스들을 제공합니다.  
  
다양한 요소 누적 방식은 Collector 인터페이스에 정의되어 있습니다.  
  
Collectors.toList()는 Collector를 반환하기 때문에 `collect(Collectors.toList())`를 하면 `collect` 메서드에 `collector` 인터페이스가 들어가는 것입니다.  
쉽게 설명하면, stream.collect(요소 누적 방식); 과 같고 요소 누적 방식은 Collector 인터페이스에 정의되어 있습니다.  
Collector 인터페이스들을 구현한 클래스가 Collectors입니다.  
## 6.1 컬렉터란 무엇인가?
함수형 프로그래밍에서는 '무엇'을 원하는지 직접 명시할 수 있어서 어떤 방법으로 이를 얻을지는 신경 쓸 필요가 없습니다.  
이전 예제에서 collect 메서드로 Collector 인터페이스 구현을 전달했습니다.  
Collector 인터페이스 구현은 `스트림의 요소를 어떤 식으로 도출할지 지정합니다`.  
  
이전까지는 toList를 Collector 인터페이스의 구현으로 사용했습니다.  
함수형 프로그래밍에서는 필요한 컬렉터를 쉽게 추가할 수 있습니다.  

### 6.1.1 고급 리듀싱 기능을 수행하는 컬렉터

### 6.1.2 미리 정의된 컬렉터

## 6.2 리듀싱과 요약 


